# Introduction to Computer Problem Solving

### 1.1 | Introduction

     Computer problem solving is demanding! requires thought, careful planning, logical precision, persistence and attention to detail.
     But is also Challenging, Exiting, and satisfiying experience with considerable room for personal creativity and expression.
     Approach with this spirit and your chances of success are greatly amplified!
     
     1.1.1 Programs and Algorithms
     - Goal of the Book : Study in depth the process of algorithm design with particular emphasis of problem solving of the task.
     - Program : A set of explicit and unambiguous instructions expressed in a programming language.
     - Input : Data provided to a program to produce the output
     - Output : Computer solution to a problem
     - Algorithm : A set of explicit and unambiguous finite steps which when carried out for a given set of initial conditions, 
     produce the corresponding output and terminate in a finite time.
     
     1.1.2 Requirements for solving problems by computer
     - Algorithm Desing requires a "CONCIOUS DEPTH UNDESTANDING" far greater than than we are likely to encounter in almost
     any other problem-solving situation.
     - Phone Directory Problem : Only when a Data Structure is symbolically linked with an algorithm we can expect high performance.
  
### 1.2 | The Problem Solving Aspect

    """ Computer problem solving is about understanding """
    
    1.2.1 Problem Definition Phase
    - Work out "what must be done?" rather than "how to do it?"
    - Extract from the problem statement ( often quite imprecise and maybe even ambiguous) a set of precisely defined tasks.
    1.2.2 Getting Started with the problem
    
    1.2.3 The use of specific examples
    1.2.4 Similarities among problems
    1.2.5 Working backwards from the solution
    1.2.6 Geneal problem-solving strategies
### 1.3 | Top-Down Design
    1.3.1 Breaking a problem into sub-problems
    1.3.2 Choice of a suitable data structure
    1.3.3 Construction of loops
    1.3.4 Establishing initial conditions for loops
    1.3.5 Finding the iterative construct
    1.3.6 Termination of loops
### 1.4 | Implementation of Algorithms
    1.4.1 Use of procedures to emphasize the modularity
    1.4.2 Choice of variable names
    1.4.3 Documentation of programs
    1.4.4 Debugging of programs
    1.4.5 Program Testing
### 1.5 | Program Verification
    1.5.1 Computer model for program execution
    1.5.2 Input and output assertions
    1.5.3 Implications and simbolic execution
    1.5.4 Verification of straight-line program segments
    1.5.5 Verification of program segments with branches
    1.5.6 Verification of program segments with loops
    1.5.7 Verification of program segments that employ arrays
    1.5.8 Proof of termination
### 1.6 | Efficiency of algorithms
    1.6.1 Redundant computations
    1.6.2 Referencing array elements
    1.6.3 Inneficiency due to late termination
    1.6.4 Early detection of desired output conditions
    1.6.5 Trading storage for efficiency gains
### 1.7 | The analysis of Algorithms
    1.7.1 Computational Complexity
    1.7.2 The order notation
    1.7.3 Worst and average case notation
    1.7.4 Probabilistic avarage case notation
    
